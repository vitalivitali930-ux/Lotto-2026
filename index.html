<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lotto 2026 | Fan Monolith VCHF</title>
    <style>
        :root {
            --vchf-gold: #d4af37;
            --vchf-gold-bright: #fff5a0;
            --vchf-red: #ff3344;
            --vchf-bg: #050505;
            --vchf-glass: rgba(0, 0, 0, 0.85);
            --shadow-glow: 0 0 15px rgba(212, 175, 55, 0.4);
        }

        * {
            margin: 0; padding: 0; box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none; -webkit-user-drag: none;
        }

        body, html {
            width: 100%; height: 100%;
            background-color: var(--vchf-bg);
            font-family: 'Orbitron', sans-serif;
            overflow: hidden; color: var(--vchf-gold);
        }

        #vchf-gate {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 10000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 1.2s ease;
        }

        .gate-logo h1 {
            font-size: clamp(40px, 15vw, 80px); letter-spacing: 15px;
            background: linear-gradient(to bottom, var(--vchf-gold-bright), var(--vchf-gold));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 15px var(--vchf-gold));
        }

        .ready-trigger {
            margin-top: 30px; padding: 15px 40px; font-size: 18px;
            background: transparent; border: 2px solid var(--vchf-gold);
            color: var(--vchf-gold); border-radius: 30px;
            cursor: pointer; letter-spacing: 5px; transition: 0.3s;
        }
        .ready-trigger:hover { background: var(--vchf-gold); color: #000; }

        /* АРЕНА */
        #game-arena {
            width: 100vw; height: 100vh;
            background: radial-gradient(circle at center, #1a0a00 0%, #000 100%);
            position: relative; display: none; z-index: 10;
        }

        #status-bar {
            position: absolute; top: 10px; left: 10px; font-size: 9px;
            letter-spacing: 1px; color: #00ffcc; z-index: 1000;
        }

        /* ТОТЕН (КОЗЫРЬ) - ПРАВЫЙ УГОЛ */
        #totem-ghost {
            position: fixed; top: 15px; right: 15px;
            width: 55px; height: 80px;
            background: var(--vchf-glass); border: 1.5px solid var(--vchf-gold);
            border-radius: 5px; display: flex; justify-content: center; align-items: center;
            font-size: 32px; z-index: 2000;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.5);
            transform: scale(0); transition: 1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #totem-ghost.active { transform: scale(1); }

        /* КРУГ (УМЕНЬШЕН НА 30%) */
        #destiny-circle {
            position: absolute; top: 35%; left: 50%;
            transform: translate(-50%, -50%); z-index: 500;
        }

        .ritual-sphere {
            position: absolute; width: 40px; height: 40px;
            background: url('1771489965074(1).png') center/cover;
            border-radius: 50%; border: 1px solid var(--vchf-gold);
            transform: translate(-50%, -50%);
        }

        /* ПОЛЕ БОЯ - ВЕЕРНОЕ НАСЛОЕНИЕ */
        #battle-field {
            position: absolute; top: 20%; width: 100%; height: 25%;
            display: flex; justify-content: center; align-items: center;
            z-index: 400; pointer-events: none;
        }

        .battle-pair {
            position: relative; width: 60px; height: 90px;
            margin-left: -30px; transition: 0.4s;
        }

        /* КАРТА МОНОЛИТА */
        .vchf-card {
            width: 70px; height: 105px;
            background: #fff; border-radius: 5px;
            position: absolute; padding: 5px;
            box-shadow: 2px 2px 8px rgba(0,0,0,0.4);
            display: flex; flex-direction: column; justify-content: space-between;
            transition: transform 0.4s ease, top 0.4s ease, left 0.4s ease;
            border: 1px solid #ccc;
        }
        .vchf-card.red { color: var(--vchf-red); }
        .vchf-card.black { color: #000; }
        .vchf-card.is-trump { border: 2px solid var(--vchf-gold); box-shadow: 0 0 10px var(--vchf-gold); }

        /* ХВАТ ОДНОЙ РУКИ (ВЕЕР) */
        #player-bud {
            position: absolute; bottom: -30px; left: 50%;
            transform: translateX(-50%);
            width: 100%; height: 45%;
            z-index: 2000;
        }

        /* Контейнер для всех карт в руке */
        #fan-container {
            position: relative; width: 100%; height: 100%;
            perspective: 1000px;
        }

        /* Центр вращения веера - твой большой палец */
        .fan-card {
            position: absolute;
            left: 50%;
            bottom: 60px;
            margin-left: -35px; /* Половина ширины карты */
            transform-origin: bottom center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .fan-card:hover {
            z-index: 5000 !important;
            transform: translate(0, -30px) scale(1.2) rotate(0deg) !important;
        }

        /* ИНТЕРФЕЙС */
        #ui-layer {
            position: absolute; bottom: 10px; width: 100%;
            display: flex; justify-content: center; gap: 20px; z-index: 3000;
        }
        .vchf-btn {
            padding: 10px 25px; background: rgba(0,0,0,0.8);
            border: 1px solid var(--vchf-gold); color: var(--vchf-gold);
            border-radius: 20px; font-size: 12px; letter-spacing: 2px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="ritual-canvas" style="position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:1;"></canvas>
    
    <div id="vchf-gate">
        <div class="gate-logo">
            <h1>VCHF</h1>
            <p style="text-align:center; letter-spacing:5px; font-size:10px; opacity:0.7;">BI-TURBO ULTIMATE</p>
        </div>
        <button class="ready-trigger" onclick="vchf_ritual_start()">РИТУАЛ</button>
    </div>

    <div id="game-arena">
        <div id="status-bar">SYSTEM: STANDBY</div>
        <div id="totem-ghost"></div>
        <div id="destiny-circle"></div>
        
        <div id="enemy-shadow" style="position:absolute; top:20px; width:100%; display:flex; justify-content:center; z-index:100;"></div>
        
        <div id="battle-field"></div>

        <div id="player-bud">
            <div id="fan-container"></div>
        </div>

        <div id="ui-layer">
            <button class="vchf-btn" id="btn-take" onclick="vchf_take()">ВЗЯТЬ</button>
            <button class="vchf-btn" id="btn-bito" onclick="vchf_bito()" disabled>БИТО</button>
        </div>
    </div>

    <script>
        /* ДВИЖОК VCHF: ВЕРСИЯ 2.1 
           ПРАВИЛО: НОВЫЙ КОД = СТАРЫЙ + ВВЕДЕННАЯ ФУНКЦИЯ
           ЯКОРЬ: vchf_go (ИДТИ)
        */

        const SUITS = ['♥', '♦', '♣', '♠'];
        const RANKS = ['6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const RANK_VAL = { '6':6,'7':7,'8':8,'9':9,'10':10,'J':11,'Q':12,'K':13,'A':14 };

        let vchf_state = {
            phase: 'gate',
            deck: [],
            pHand: [],
            eHand: [],
            table: [],
            trump: null,
            turn: 'player',
            is_thinking: false
        };

        function vchf_log(m) { document.getElementById('status-bar').innerText = `SYS: ${m}`; }

        function vchf_ritual_start() {
            if (vchf_state.phase !== 'gate') return;
            document.getElementById('vchf-gate').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('vchf-gate').style.display = 'none';
                document.getElementById('game-arena').style.display = 'block';
                vchf_init_deck();
                vchf_spawn_destiny_circle();
                vchf_start_bg_particles();
                vchf_log("РИТУАЛ АКТИВИРОВАН. ВЫБЕРИТЕ СФЕРУ.");
            }, 1200);
        }

        function vchf_init_deck() {
            vchf_state.deck = [];
            let id = 1;
            SUITS.forEach(suit => {
                RANKS.forEach(rank => {
                    vchf_state.deck.push({
                        id: id++, suit: suit, rank: rank,
                        val: RANK_VAL[rank],
                        color: (suit === '♥' || suit === '♦') ? 'red' : 'black'
                    });
                });
            });
            // Честная тасовка VCHF
            for (let i = vchf_state.deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [vchf_state.deck[i], vchf_state.deck[j]] = [vchf_state.deck[j], vchf_state.deck[i]];
            }
        }

        /* МАТЕМАТИКА ВЕЕРА "ОДНОЙ РУКИ" */
        function vchf_render_player_hand() {
            const container = document.getElementById('fan-container');
            container.innerHTML = '';
            
            const cards = vchf_state.pHand;
            const total = cards.length;
            if (total === 0) return;

            // Настройка веера: угол и радиус
            const maxSpread = 70; // Общий угол раскрытия веера в градусах
            const angleStep = total > 1 ? maxSpread / (total - 1) : 0;
            const startAngle = -(maxSpread / 2);
            
            // Твой принцип: 75% нахлеста = 25% видимости
            const horizontalStep = 22; // Смещение в пикселях для компактности

            cards.forEach((card, i) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'fan-card';
                
                // Расчет угла для каждой карты
                const currentAngle = startAngle + (i * angleStep);
                
                // Расчет смещения по дуге (чтобы веер был круглым)
                const xOffset = (i - (total - 1) / 2) * horizontalStep;
                const yOffset = Math.abs(xOffset) * 0.2; // Небольшой подъем краев

                wrapper.style.zIndex = 100 + i;
                wrapper.style.transform = `translate(${xOffset}px, ${yOffset}px) rotate(${currentAngle}deg)`;

                const el = document.createElement('div');
                el.className = `vchf-card ${card.color} ${card.suit === vchf_state.trump ? 'is-trump' : ''}`;
                el.innerHTML = `
                    <div style="font-size:12px; font-weight:900">${card.rank}</div>
                    <div style="font-size:22px; align-self:center">${card.suit}</div>
                    <div style="font-size:12px; font-weight:900; transform:rotate(180deg)">${card.rank}</div>
                `;
                
                // ГЛАВНЫЙ ЯКОРЬ: ИДТИ
                el.onclick = () => vchf_go(card);
                
                wrapper.appendChild(el);
                container.appendChild(wrapper);
            });
        }
        function vchf_spawn_destiny_circle() {
            vchf_state.phase = 'gathering';
            const circle = document.getElementById('destiny-circle');
            circle.innerHTML = '';
            
            // УМЕНЬШЕНИЕ РАДИУСА НА 30% ДЛЯ ВЫСВОБОЖДЕНИЯ МЕСТА
            const radius = Math.min(window.innerWidth, window.innerHeight) * 0.25;
            
            vchf_state.deck.forEach((card, i) => {
                const sphere = document.createElement('div');
                sphere.className = 'ritual-sphere';
                sphere.id = `sphere-${card.id}`;
                
                const angle = (i / 36) * Math.PI * 2;
                const tx = Math.cos(angle) * radius;
                const ty = Math.sin(angle) * radius;

                // Хаотичные координаты для тасовки (Мешание)
                const rx = (Math.random() - 0.5) * window.innerWidth * 1.5;
                const ry = (Math.random() - 0.5) * window.innerHeight * 1.5;

                sphere.style.setProperty('--rx', `${rx}px`);
                sphere.style.setProperty('--ry', `${ry}px`);
                sphere.style.setProperty('--tx', `${tx}px`);
                sphere.style.setProperty('--ty', `${ty}px`);

                // Анимация входа: из хаоса в круг
                sphere.style.left = '0px';
                sphere.style.top = '0px';
                sphere.style.animation = `chaos-shuffle ${1.2 + Math.random()}s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards`;

                sphere.onclick = () => vchf_capture(card.id);
                circle.appendChild(sphere);
            });
        }

        function vchf_capture(cardId) {
            if (vchf_state.phase !== 'gathering') return;
            
            const cardIdx = vchf_state.deck.findIndex(c => c.id === cardId);
            if (cardIdx === -1) return;
            
            const card = vchf_state.deck.splice(cardIdx, 1)[0];
            vchf_animate_capture(card, 'player');
            
            // ТЕНЬ ВЫБИРАЕТ СВОЮ СФЕРУ (ОТВЕТНЫЙ ХОД)
            if (vchf_state.deck.length > 0) {
                setTimeout(() => {
                    const aiIdx = Math.floor(Math.random() * vchf_state.deck.length);
                    const aiCard = vchf_state.deck.splice(aiIdx, 1)[0];
                    vchf_animate_capture(aiCard, 'enemy');
                    
                    if (vchf_state.deck.length === 0) vchf_init_battle_phase();
                }, 200);
            } else {
                vchf_init_battle_phase();
            }
        }

        function vchf_animate_capture(card, owner) {
            const sphere = document.getElementById(`sphere-${card.id}`);
            if (!sphere) return;

            sphere.style.transition = 'all 0.9s cubic-bezier(0.19, 1, 0.22, 1)';
            sphere.style.zIndex = '5000';
            
            if (owner === 'player') {
                // Полет в "Бутон" (Веер)
                sphere.style.top = `${window.innerHeight * 0.5}px`;
                sphere.style.left = '0px';
                sphere.style.transform = 'scale(0.3) rotate(1080deg)';
                sphere.style.opacity = '0';
                vchf_state.pHand.push(card);
            } else {
                // Полет в "Тень" (Вверх)
                sphere.style.top = `-${window.innerHeight * 0.5}px`;
                sphere.style.transform = 'scale(0.1) rotate(-720deg)';
                sphere.style.opacity = '0';
                vchf_state.eHand.push(card);
            }

            setTimeout(() => {
                sphere.remove();
                vchf_render_player_hand();
                vchf_render_enemy_shadow();
            }, 900);
        }

        function vchf_render_enemy_shadow() {
            const shadow = document.getElementById('enemy-shadow');
            shadow.innerHTML = '';
            vchf_state.eHand.forEach((_, i) => {
                const back = document.createElement('div');
                back.className = 'enemy-card-back';
                back.style.width = '40px';
                back.style.height = '60px';
                back.style.background = 'linear-gradient(135deg, #1a1a1a, #000)';
                back.style.border = '1px solid var(--vchf-gold)';
                back.style.borderRadius = '4px';
                back.style.marginLeft = i === 0 ? '0' : '-25px'; // Нахлест вражеских карт
                back.style.boxShadow = '-2px 0 5px rgba(0,0,0,0.5)';
                shadow.appendChild(back);
            });
        }

        function vchf_init_battle_phase() {
            if (vchf_state.phase === 'battle') return;
            vchf_state.phase = 'battle';
            
            // Назначение Козыря (Тотема)
            vchf_state.trump = SUITS[Math.floor(Math.random() * SUITS.length)];
            vchf_log(`КОЗЫРЬ: ${vchf_state.trump}. ВАШ ХОД.`);
            
            const totem = document.getElementById('totem-ghost');
            totem.innerHTML = vchf_state.trump;
            totem.style.color = (vchf_state.trump === '♥' || vchf_state.trump === '♦') ? 'var(--vchf-red)' : '#fff';
            
            setTimeout(() => {
                totem.classList.add('active');
                vchf_render_player_hand(); // Обновляем веер, чтобы подсветить козыри
            }, 600);
        }
        /* ГЛАВНЫЙ КОНТРОЛЛЕР ХОДА (ЯКОРЬ: ИДТИ) */
        function vchf_go(card) {
            if (vchf_state.phase !== 'battle' || vchf_state.is_thinking) return;

            // Если сейчас ход игрока (Атака или Подкидывание)
            if (vchf_state.turn === 'player') {
                const lastPair = vchf_state.table[vchf_state.table.length - 1];
                
                // Если стол пуст или последняя пара закрыта - ИГРОК АТАКУЕТ
                if (!lastPair || lastPair.defense !== null) {
                    vchf_player_attack(card);
                } else {
                    // Иначе - ИГРОК ЗАЩИЩАЕТСЯ (Кроет карту Тени)
                    vchf_player_defend(card);
                }
            }
        }

        function vchf_player_attack(card) {
            // Лимит карт на столе (не больше 6 или сколько у Тени в руке)
            if (vchf_state.table.length >= 6 || vchf_state.table.length >= vchf_state.eHand.length + (vchf_state.table.filter(p => !p.defense).length)) {
                vchf_log("ПРЕДЕЛ КАРТ НА СТОЛЕ!");
                return;
            }

            // Правило подкидывания
            if (vchf_state.table.length > 0) {
                const ranksOnTable = [];
                vchf_state.table.forEach(p => {
                    ranksOnTable.push(p.attack.rank);
                    if (p.defense) ranksOnTable.push(p.defense.rank);
                });
                if (!ranksOnTable.includes(card.rank)) {
                    vchf_log("РАНГ НЕ ПОДХОДИТ ДЛЯ ПОДКИДЫВАНИЯ!");
                    return;
                }
            }

            const idx = vchf_state.pHand.indexOf(card);
            vchf_state.pHand.splice(idx, 1);
            vchf_state.table.push({ attack: card, defense: null });
            
            vchf_render_battlefield();
            vchf_render_player_hand();
            vchf_log(`ВЫ ИДЕТЕ: ${card.rank}${card.suit}`);
            
            // Тень начинает думать над защитой
            vchf_state.is_thinking = true;
            setTimeout(() => vchf_ai_defend(card), 1000);
        }

        function vchf_player_defend(card) {
            const lastPair = vchf_state.table[vchf_state.table.length - 1];
            const attackCard = lastPair.attack;

            // Логика: можно побить той же мастью выше ИЛИ козырем (если атака не козырь)
            const canCover = (card.suit === attackCard.suit && card.val > attackCard.val) ||
                             (card.suit === vchf_state.trump && attackCard.suit !== vchf_state.trump);

            if (canCover) {
                const idx = vchf_state.pHand.indexOf(card);
                vchf_state.pHand.splice(idx, 1);
                lastPair.defense = card;
                
                vchf_render_battlefield();
                vchf_render_player_hand();
                vchf_log(`ВЫ ПОКРЫЛИ: ${card.rank}${card.suit}`);
                
                vchf_check_game_end();
                // После защиты ход остается у Тени (она может подкинуть)
            } else {
                vchf_log("ЭТОЙ КАРТОЙ НЕЛЬЗЯ ПОКРЫТЬ!");
            }
        }

        /* ОТРЕСОВКА ПОЛЯ БОЯ (ЭФФЕКТ ВЕЕРА НА СТОЛЕ) */
        function vchf_render_battlefield() {
            const field = document.getElementById('battle-field');
            field.innerHTML = '';
            
            vchf_state.table.forEach((pair, index) => {
                const pairContainer = document.createElement('div');
                pairContainer.className = 'battle-pair';
                
                // Твой принцип: Каскадное наслоение пар на столе
                pairContainer.style.zIndex = 10 + index;
                pairContainer.style.transform = `rotate(${(index - 2) * 3}deg) translateY(${Math.abs(index - 2) * 5}px)`;

                // Карта Атаки
                const aCard = vchf_create_card_el(pair.attack);
                pairContainer.appendChild(aCard);
                
                // Карта Защиты (ложится сверху со смещением)
                if (pair.defense) {
                    const dCard = vchf_create_card_el(pair.defense);
                    dCard.style.position = 'absolute';
                    dCard.style.top = '15px';
                    dCard.style.left = '15px';
                    dCard.style.zIndex = 100;
                    dCard.style.transform = 'rotate(5deg)';
                    pairContainer.appendChild(dCard);
                }
                
                field.appendChild(pairContainer);
            });

            // Обновление состояния кнопок
            const btnBito = document.getElementById('btn-bito');
            const btnTake = document.getElementById('btn-take');
            
            // БИТО активно, если все карты на столе покрыты и ход игрока
            btnBito.disabled = !(vchf_state.table.length > 0 && vchf_state.table.every(p => p.defense !== null) && vchf_state.turn === 'player');
            // ВЗЯТЬ активно, если есть что брать и ход не игрока (его атакуют)
            btnTake.disabled = !(vchf_state.table.length > 0 && vchf_state.turn === 'enemy');
        }

        function vchf_create_card_el(card) {
            const el = document.createElement('div');
            el.className = `vchf-card ${card.color} ${card.suit === vchf_state.trump ? 'is-trump' : ''}`;
            el.innerHTML = `
                <div style="font-size:12px; font-weight:900">${card.rank}</div>
                <div style="font-size:22px; align-self:center">${card.suit}</div>
                <div style="font-size:12px; font-weight:900; transform:rotate(180deg)">${card.rank}</div>
            `;
            return el;
        }
        /* ЛОГИКА ТЕНИ: ЗАЩИТА (ОТВЕТ НА ТВОЕ "ИДТИ") */
        function vchf_ai_defend(attackCard) {
            vchf_log("ТЕНЬ ИЗУЧАЕТ ВАШ ХОД...");
            
            // Фильтруем карты, которыми Тень может покрыться
            let candidates = vchf_state.eHand.filter(c => {
                // Та же масть выше Рангом
                const sameSuitHigher = (c.suit === attackCard.suit && c.val > attackCard.val);
                // Или козырь (если атака — не козырь)
                const trumpCover = (vchf_state.trump !== attackCard.suit && c.suit === vchf_state.trump);
                return sameSuitHigher || trumpCover;
            });

            // Сортируем кандидатов, чтобы Тень была умной:
            // 1. Сначала простые карты (не козыри), от меньшей к большей
            // 2. В конце — козыри, от меньших к большим
            candidates.sort((a, b) => {
                const aIsTrump = (a.suit === vchf_state.trump);
                const bIsTrump = (b.suit === vchf_state.trump);
                if (aIsTrump && !bIsTrump) return 1;
                if (!aIsTrump && bIsTrump) return -1;
                return a.val - b.val;
            });

            const defenseCard = candidates[0];

            if (defenseCard) {
                setTimeout(() => {
                    const idx = vchf_state.eHand.indexOf(defenseCard);
                    vchf_state.eHand.splice(idx, 1);
                    
                    // Кладем карту защиты в текущую пару на столе
                    vchf_state.table[vchf_state.table.length - 1].defense = defenseCard;
                    
                    vchf_render_battlefield();
                    vchf_render_enemy_shadow();
                    vchf_log(`ТЕНЬ ПОКРЫЛА: ${defenseCard.rank}${defenseCard.suit}`);
                    
                    vchf_state.is_thinking = false;
                    vchf_check_game_end();
                }, 1200);
            } else {
                // ТЕНЬ НЕ МОЖЕТ ПОКРЫТЬСЯ - ЗАБИРАЕТ СТОЛ
                setTimeout(() => {
                    vchf_log("ТЕНЬ ПРИНИМАЕТ КАРТЫ.");
                    vchf_state.table.forEach(pair => {
                        vchf_state.eHand.push(pair.attack);
                        if (pair.defense) vchf_state.eHand.push(pair.defense);
                    });
                    vchf_state.table = [];
                    vchf_render_enemy_shadow();
                    vchf_render_battlefield();
                    
                    vchf_state.is_thinking = false;
                    vchf_draw_missing_cards(); // Добор из колоды
                    vchf_check_game_end();
                    // Ход остается у игрока, так как ИИ "взял"
                }, 1000);
            }
        }

        /* ДОБОР КАРТ ИЗ КОЛОДЫ (ПОСЛЕ БИТО ИЛИ ВЗЯЛ) */
        function vchf_draw_missing_cards() {
            // Сначала добирает тот, кто ходил (атакующий)
            // В данном случае упростим: добор по 6 карт каждому
            while (vchf_state.pHand.length < 6 && vchf_state.deck.length > 0) {
                vchf_state.pHand.push(vchf_state.deck.pop());
            }
            while (vchf_state.eHand.length < 6 && vchf_state.deck.length > 0) {
                vchf_state.eHand.push(vchf_state.deck.pop());
            }
            vchf_render_player_hand();
            vchf_render_enemy_shadow();
        }

        function vchf_bito() {
            if (vchf_state.turn !== 'player' || vchf_state.table.length === 0) return;
            
            vchf_log("БИТО. ОЧИСТКА ПОЛЯ.");
            vchf_state.table = []; // Карты уходят в отбой
            vchf_render_battlefield();
            
            vchf_draw_missing_cards();
            
            // Смена хода: теперь атакует Тень
            vchf_state.turn = 'enemy';
            vchf_check_game_end();
            
            setTimeout(vchf_ai_attack, 1500);
        }

        function vchf_take() {
            if (vchf_state.turn !== 'enemy' || vchf_state.table.length === 0) return;
            
            vchf_log("ВЫ ЗАБРАЛИ КАРТЫ.");
            vchf_state.table.forEach(pair => {
                vchf_state.pHand.push(pair.attack);
                if (pair.defense) vchf_state.pHand.push(pair.defense);
            });
            vchf_state.table = [];
            
            vchf_draw_missing_cards();
            vchf_render_player_hand();
            vchf_render_battlefield();
            
            // Ход остается у Тени, так как игрок "взял"
            vchf_state.turn = 'enemy';
            setTimeout(vchf_ai_attack, 1500);
        }
        /* ЛОГИКА ТЕНИ: АТАКА (ОНА ИДЕТ К ВАМ) */
        function vchf_ai_attack() {
            if (vchf_state.phase !== 'battle' || vchf_state.eHand.length === 0) return;
            vchf_state.is_thinking = true;
            vchf_state.turn = 'enemy';

            let attackCard = null;

            if (vchf_state.table.length === 0) {
                // ПЕРВЫЙ ХОД ТЕНИ: Выбирает самую слабую не козырную карту
                let candidates = vchf_state.eHand.sort((a, b) => {
                    const aIsT = (a.suit === vchf_state.trump);
                    const bIsT = (b.suit === vchf_state.trump);
                    if (aIsT && !bIsT) return 1;
                    if (!aIsT && bIsT) return -1;
                    return a.val - b.val;
                });
                attackCard = candidates[0];
            } else {
                // ПОДКИДЫВАНИЕ: Ищет карту того же ранга, что уже на столе
                const ranksOnTable = [];
                vchf_state.table.forEach(p => {
                    ranksOnTable.push(p.attack.rank);
                    if (p.defense) ranksOnTable.push(p.defense.rank);
                });
                
                attackCard = vchf_state.eHand.find(c => ranksOnTable.includes(c.rank));
            }

            // Если карта найдена и лимит стола не превышен
            if (attackCard && vchf_state.table.length < 6) {
                setTimeout(() => {
                    const idx = vchf_state.eHand.indexOf(attackCard);
                    vchf_state.eHand.splice(idx, 1);
                    
                    vchf_state.table.push({ attack: attackCard, defense: null });
                    
                    vchf_render_battlefield();
                    vchf_render_enemy_shadow();
                    vchf_log(`ТЕНЬ ИДЕТ: ${attackCard.rank}${attackCard.suit}`);
                    
                    vchf_state.is_thinking = false;
                    // Теперь ЖДЕМ, когда игрок нажмет на карту в ВЕЕРЕ (vchf_go) для защиты
                }, 1200);
            } else {
                // ТЕНИ НЕЧЕГО ПОДКИДЫВАТЬ - БИТО
                vchf_log("ТЕНЬ ГОВОРИТ: БИТО.");
                setTimeout(() => {
                    vchf_state.table = [];
                    vchf_render_battlefield();
                    vchf_draw_missing_cards();
                    vchf_state.turn = 'player'; // Ход переходит к игроку
                    vchf_state.is_thinking = false;
                    vchf_check_game_end();
                }, 1000);
            }
        }

        /* ТРИГГЕР ДЛЯ АВТО-АТАКИ ТЕНИ */
        setInterval(() => {
            if (vchf_state.phase === 'battle' && vchf_state.turn === 'enemy' && !vchf_state.is_thinking) {
                // Если стол пуст ИЛИ последняя карта игроком покрыта — Тень атакует/подкидывает
                const lastPair = vchf_state.table[vchf_state.table.length - 1];
                if (!lastPair || lastPair.defense !== null) {
                    vchf_ai_attack();
                }
            }
        }, 2500);

        /* ПРОВЕРКА ФИНАЛА ЦИКЛА */
        function vchf_check_game_end() {
            if (vchf_state.deck.length === 0) {
                if (vchf_state.pHand.length === 0 && vchf_state.eHand.length === 0) {
                    vchf_finish("НИЧЬЯ. ХАОС УРАВНОВЕШЕН.");
                } else if (vchf_state.pHand.length === 0) {
                    vchf_finish("ПОБЕДА! ЗОЛОТО VCHF ВАШЕ.");
                } else if (vchf_state.eHand.length === 0) {
                    vchf_finish("ТЕНЬ ВЗЯЛА ВЕРХ. ПОПРОБУЙТЕ СНОВА.");
                }
            }
        }

        function vchf_finish(msg) {
            vchf_state.phase = 'end';
            const gate = document.getElementById('vchf-gate');
            gate.style.display = 'flex';
            gate.style.opacity = '1';
            gate.innerHTML = `
                <div class="gate-logo">
                    <h2 style="color:var(--vchf-gold); font-size:24px; text-align:center;">${msg}</h2>
                    <button class="ready-trigger" onclick="location.reload()">НОВЫЙ ЦИКЛ</button>
                </div>
            `;
            
            // Вспышка Хаоса
            document.getElementById('game-arena').style.filter = 'brightness(5) contrast(2)';
            setTimeout(() => {
                document.getElementById('game-arena').style.filter = 'none';
            }, 500);
        }
        /* ВИЗУАЛЬНЫЙ ДВИЖОК ЧАСТИЦ (ЗОЛОТАЯ ПЫЛЬ VCHF) */
        let vchf_particles = [];
        const vchf_canvas = document.getElementById('ritual-canvas');
        const vchf_ctx = vchf_canvas.getContext('2d');

        function vchf_start_bg_particles() {
            vchf_resize_canvas();
            window.addEventListener('resize', vchf_resize_canvas);
            vchf_create_particles();
            vchf_animate_particles();
        }

        function vchf_resize_canvas() {
            vchf_canvas.width = window.innerWidth;
            vchf_canvas.height = window.innerHeight;
        }

        function vchf_create_particles() {
            vchf_particles = [];
            // Создаем 42 частицы Хаоса (по числу сфер судьбы в расширенном протоколе)
            for (let i = 0; i < 42; i++) {
                vchf_particles.push({
                    x: Math.random() * vchf_canvas.width,
                    y: Math.random() * vchf_canvas.height,
                    size: Math.random() * 2 + 0.5,
                    speedY: Math.random() * 0.4 + 0.1,
                    speedX: (Math.random() - 0.5) * 0.2,
                    opacity: Math.random() * 0.5 + 0.1
                });
            }
        }

        function vchf_animate_particles() {
            vchf_ctx.clearRect(0, 0, vchf_canvas.width, vchf_canvas.height);
            
            vchf_particles.forEach(p => {
                p.y -= p.speedY; // Пыль медленно поднимается вверх
                p.x += p.speedX;
                
                // Возврат частиц, если ушли за экран
                if (p.y < -10) {
                    p.y = vchf_canvas.height + 10;
                    p.x = Math.random() * vchf_canvas.width;
                }
                if (p.x < 0) p.x = vchf_canvas.width;
                if (p.x > vchf_canvas.width) p.x = 0;

                vchf_ctx.globalAlpha = p.opacity;
                vchf_ctx.fillStyle = '#d4af37'; // Золото VCHF
                vchf_ctx.beginPath();
                vchf_ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                vchf_ctx.fill();
            });
            
            // Если игра активна, частицы ускоряются
            if (vchf_state.phase === 'battle') {
                vchf_ctx.shadowBlur = 10;
                vchf_ctx.shadowColor = '#d4af37';
            } else {
                vchf_ctx.shadowBlur = 0;
            }

            requestAnimationFrame(vchf_animate_particles);
        }

        /* КОРРЕКТИРОВКА "ХВАТА ОДНОЙ РУКИ" ПРИ ИЗМЕНЕНИИ РАЗМЕРА */
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                vchf_resize_canvas();
                vchf_render_player_hand();
                vchf_render_battlefield();
            }, 500);
        });

        /* АНИМАЦИЯ ХАОСА ПРИ ТАСОВКЕ (CSS KEYFRAMES INJECTOR) */
        const styleSheet = document.createElement("style");
        styleSheet.innerText = `
            @keyframes chaos-shuffle {
                0% { transform: translate(var(--rx), var(--ry)) scale(0) rotate(0deg); opacity: 0; }
                50% { opacity: 1; }
                100% { transform: translate(var(--tx), var(--ty)) scale(1) rotate(720deg); opacity: 1; }
            }
            .enemy-card-back {
                transition: transform 0.3s ease;
            }
            .enemy-card-back:hover {
                transform: translateY(-10px);
            }
        `;
        document.head.appendChild(styleSheet);
        /* СИСТЕМА КОНТРОЛЯ ЦЕЛОСТНОСТИ МОНОЛИТА */
        function vchf_integrity_sync() {
            // Проверка: сумма всех карт в системе всегда должна быть 36
            const deckCount = vchf_state.deck.length;
            const pHandCount = vchf_state.pHand.length;
            const eHandCount = vchf_state.eHand.length;
            let tableCount = 0;
            vchf_state.table.forEach(pair => {
                tableCount += 1; // атака
                if (pair.defense) tableCount += 1; // защита
            });

            const total = deckCount + pHandCount + eHandCount + tableCount;

            if (total !== 36 && vchf_state.phase !== 'gathering') {
                vchf_log("CRITICAL: КВАНТОВЫЙ РАЗРЫВ КОЛОДЫ!");
                console.warn(`В системе обнаружено: ${total} карт из 36.`);
            }
        }

        // Запуск мониторинга каждые 10 секунд
        setInterval(vchf_integrity_sync, 10000);

        /* ИНИЦИАЦИЯ ПРИ ЗАГРУЗКЕ ОКНА */
        window.onload = () => {
            vchf_log("СИСТЕМА ГОТОВА. РИТУАЛ ЖДЕТ.");
            console.log("-----------------------------------------");
            console.log("ПРОЕКТ: LOTTO 2026 (BI-TURBO)");
            console.log("МОДЕЛЬ: НУЛЕВОЙ ХАОС");
            console.log("ЯКОРЬ: vchf_go (ИДТИ) — АКТИВЕН");
            console.log("ГЕОМЕТРИЯ: ХВАТ ВАНДЕРЕРА (ВЕЕР) — ЗАГРУЖЕНА");
            console.log("СТАТУС: МОНОЛИТ СОБРАН. 0% ПОТЕРЬ.");
            console.log("-----------------------------------------");
        };

        /* ОБРАБОТЧИК ОШИБОК (АНТИ-КРАШ) */
        window.onerror = function(message, source, lineno, colno, error) {
            vchf_log(`ERROR L${lineno}: ${message.substring(0, 20)}...`);
            return true; // Предотвращает падение скрипта
        };

        /* КОНЕЦ МАНИФЕСТА МОНОЛИТА */
    </script>
</body>
</html>
