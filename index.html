<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lotto Bi-Turbo Ultimate 2026 | VCHF</title>
    <style>
        :root {
            --vchf-glow: 0 0 20px #00ff00;
            --chaos-red: #ff0033;
            --gold: #d4af37;
            --gold-bright: #fff5a0;
            --bg-deep: #050505;
            --cherry-velvet: radial-gradient(circle at center, #5a0010 0%, #000 100%);
            --glass: rgba(0, 0, 0, 0.85);
        }

        * { 
            -webkit-tap-highlight-color: transparent; 
            box-sizing: border-box; 
            margin: 0; padding: 0; 
        }

        body, html { 
            width: 100%; height: 100%; 
            background: #000; overflow: hidden; 
            font-family: 'Orbitron', sans-serif; 
            color: var(--gold); user-select: none;
        }

        #ritual-canvas {
            position: fixed; top: 0; left: 0; 
            width: 100%; height: 100%;
            z-index: -1; pointer-events: none;
        }

        /* ГЛАВНАЯ АРЕНА */
        #game-table { 
            width: 100vw; height: 100vh; 
            background: var(--cherry-velvet); 
            position: relative; display: none; 
        }

        /* ЭКРАН ВХОДА (ДЛЯ ТЕЛЕФОНА) */
        #vchf-gate {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 99999; 
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
        }
        .ready-trigger {
            padding: 15px 40px; font-size: 20px; font-weight: 900;
            background: transparent; border: 3px solid var(--gold);
            color: var(--gold); border-radius: 50px; cursor: pointer;
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.4); 
            text-transform: uppercase; letter-spacing: 5px;
        }

        /* БАРАБАН СУДЬБЫ (ЦЕНТРИРОВАНИЕ ПОД ТАП) */
        #ritual-circle { 
            position: absolute; top: 35%; left: 50%; 
            width: 1px; height: 1px; 
            transform: translate(-50%, -50%); z-index: 100; 
        }
        .card-sphere { 
            position: absolute; width: 50px; height: 75px; 
            background: #111 url('1771489965074(1).png') center/cover;
            border: 1px solid var(--gold); border-radius: 6px;
            transition: all 0.6s cubic-bezier(0.19, 1, 0.22, 1);
            box-shadow: 0 5px 15px rgba(0,0,0,0.8);
        }

        /* ТОТЕМ КОЗЫРЯ (РИТУАЛ РОЖДЕНИЯ) */
        #totem {
            position: absolute; top: 35%; left: 50%; 
            transform: translate(-50%, -50%) scale(0);
            font-size: 100px; z-index: 500; 
            transition: all 1.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            pointer-events: none; text-shadow: 0 0 30px var(--gold);
        }
        #totem.born { transform: translate(-50%, -50%) scale(1.5); opacity: 1; }
        #totem.fly { 
            top: 52%; left: 85%; 
            transform: translate(-50%, -50%) scale(0.5); 
            opacity: 0.9; 
        }

        /* БУТОН: 4 РЯДА (ДЛЯ ТВОИХ ПАЛЬЦЕВ) */
        #vchf-bud {
            position: absolute; bottom: 0; width: 100%; height: 48%;
            background: var(--glass); backdrop-filter: blur(10px);
            border-top: 2px solid var(--gold); z-index: 1000;
            display: none; flex-direction: column; padding: 4px;
        }
        .suit-row {
            flex: 1; display: flex; align-items: center; 
            gap: 2px; margin-bottom: 2px; position: relative;
            padding-left: 5px; border-radius: 5px;
            overflow-x: auto; scrollbar-width: none;
        }
        .suit-row::-webkit-scrollbar { display: none; }
        .suit-row.trump-aura { 
            background: linear-gradient(90deg, rgba(212,175,55,0.15) 0%, transparent 100%);
            box-shadow: inset 0 -5px 15px rgba(212,175,55,0.1);
        }

        /* КАРТА В РЯДУ (ОТ 6 ДО ТУЗА) */
        .card-face {
            min-width: 42px; height: 90%; background: #fff; 
            border-radius: 4px; color: #000; font-weight: 900;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 3px; font-size: 12px; transition: transform 0.2s;
        }
        .card-face.red { color: var(--chaos-red); }
        .card-face.trump-border { border: 2px solid var(--gold); }

        /* ИНТЕРФЕЙС БОЯ */
        #action-bar {
            position: absolute; top: -55px; right: 10px; 
            display: flex; gap: 8px;
        }
        .vchf-btn {
            padding: 8px 20px; background: #000; border: 2px solid var(--gold);
            color: var(--gold); border-radius: 4px; font-size: 12px;
            text-transform: uppercase; font-weight: 900;
        }
        
        #battle-ground {
            position: absolute; top: 10%; left: 0; width: 100%; height: 40%;
            display: flex; justify-content: center; align-items: center; 
            flex-wrap: wrap; gap: 10px; padding: 20px;
        }
    </style>
</head>
<body>
    <canvas id="ritual-canvas"></canvas>
    <div id="vchf-gate">
        <h1 style="color: var(--gold); margin-bottom: 30px; letter-spacing: 15px;">VCHF</h1>
        <button class="ready-trigger" onclick="startRitual()">ГОТОВ</button>
    </div>

    <div id="game-table">
        <div id="status-msg" style="position:absolute; top:15px; left:15px; font-size:10px; color:#00ff00;">SYSTEM: STANDBY</div>
        <div id="ritual-circle"></div>
        <div id="totem">?</div>
        <div id="battle-ground"></div>
        
        <div id="vchf-bud">
            <div id="action-bar">
                <button class="vchf-btn" onclick="handleTake()">ВЗЯТЬ</button>
                <button id="btn-bito" class="vchf-btn" onclick="handleBito()" disabled>БИТО</button>
            </div>
            <div id="row-hearts" class="suit-row"></div> <div id="row-diamonds" class="suit-row"></div> <div id="row-clubs" class="suit-row"></div> <div id="row-spades" class="suit-row"></div> </div>
    </div>
    <script>
        // --- WINDOW 2: ENGINE VCHF & SPHERE COORDINATES ---
        
        const SUITS = ['♥', '♦', '♣', '♠']; // Порядок рядов сверху вниз
        const RANKS = ['6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const RANK_VALUES = { '6':6, '7':7, '8':8, '9':9, '10':10, 'J':11, 'Q':12, 'K':13, 'A':14 };
        
        let vchf_state = {
            deck: [],
            pHand: [],
            eHand: [],
            table: [],
            trump: null,
            oldTrump: null,
            isMirrorRound: false,
            turn: 'player',
            active: false,
            phase: 'gathering', // 'gathering', 'battle', 'take_window'
            isAISelecting: false,
            lastSphereId: null
        };

        function logStatus(msg) {
            document.getElementById('status-msg').innerText = `SYSTEM: ${msg}`;
        }

        // Создание 36 сфер и их расстановка в круг
        function createRitualDeck() {
            const circle = document.getElementById('ritual-circle');
            circle.innerHTML = '';
            vchf_state.deck = [];

            let rawDeck = [];
            SUITS.forEach(suit => {
                RANKS.forEach(rank => {
                    rawDeck.push({
                        suit, rank, val: RANK_VALUES[rank],
                        id: 'vchf_' + Math.random().toString(36).substr(2, 9)
                    });
                });
            });

            // Перемешивание Хаоса
            for (let i = rawDeck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [rawDeck[i], rawDeck[j]] = [rawDeck[j], rawDeck[i]];
            }
            vchf_state.deck = rawDeck;

            // РАСЧЕТ КРУГА ПОД ТЕЛЕФОН (Адаптивный радиус)
            const screenWidth = window.innerWidth;
            const radius = Math.min(screenWidth * 0.35, 140); // Не более 140px, чтобы не вылезло

            vchf_state.deck.forEach((card, i) => {
                const angle = (i / 36) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;

                const sphere = document.createElement('div');
                sphere.className = 'card-sphere';
                sphere.id = card.id;
                // Сдвиг на половину размера карты (25x37) для центровки
                sphere.style.left = `${x - 25}px`;
                sphere.style.top = `${y - 37}px`;
                sphere.style.transform = `rotate(${angle + Math.PI/2}rad)`;
                
                sphere.onclick = () => playerSelectsFromCircle(card);
                circle.appendChild(sphere);
            });
        }

        // Вход в Ритуал
        function startRitual() {
            document.getElementById('vchf-gate').style.display = 'none';
            document.getElementById('game-table').style.display = 'block';
            createRitualDeck();
            vchf_state.active = true;
            logStatus("БАРАБАН СУДЬБЫ: ВЫБИРАЙТЕ 18 СФЕР");
            
            // Если первый ход не твой (шанс 50/50)
            if (Math.random() > 0.5) {
                vchf_state.isAISelecting = true;
                setTimeout(aiSelectsFromCircle, 1000);
            }
        }

        // Рендеринг Бутона (4 ряда, сортировка 6->Туз)
        function renderBud() {
            SUITS.forEach(suit => {
                const rowId = suit === '♥' ? 'row-hearts' : 
                              suit === '♦' ? 'row-diamonds' : 
                              suit === '♣' ? 'row-clubs' : 'row-spades';
                const rowEl = document.getElementById(rowId);
                rowEl.innerHTML = '';

                // Фильтруем карты по масти и сортируем по весу
                const suitCards = vchf_state.pHand
                    .filter(c => c.suit === suit)
                    .sort((a, b) => a.val - b.val);

                suitCards.forEach(card => {
                    const cardEl = document.createElement('div');
                    cardEl.className = `card-face ${ (card.suit === '♥' || card.suit === '♦') ? 'red' : '' } ${ (card.suit === vchf_state.trump) ? 'trump-border' : '' }`;
                    
                    cardEl.innerHTML = `
                        <div>${card.rank}</div>
                        <div style="font-size:20px; align-self:center;">${card.suit}</div>
                        <div style="transform:rotate(180deg);">${card.rank}</div>
                    `;
                    cardEl.onclick = () => handleCardPlay(card);
                    rowEl.appendChild(cardEl);
                });
            });
        }
        // --- WINDOW 3: GATHERING LOGIC & TRUMP RITUAL ---

        function playerSelectsFromCircle(card) {
            if (vchf_state.phase !== 'gathering' || vchf_state.isAISelecting) return;
            
            takeSphere(card, 'player');
            vchf_state.isAISelecting = true;
            
            if (vchf_state.deck.length > 0) {
                logStatus("ИИ ВЫБИРАЕТ СВОЮ СУДЬБУ...");
                setTimeout(aiSelectsFromCircle, 600);
            } else {
                finalizeGathering();
            }
        }

        function aiSelectsFromCircle() {
            if (vchf_state.deck.length === 0) {
                finalizeGathering();
                return;
            }

            // Интуитивный выбор ИИ из оставшихся сфер
            const randomIndex = Math.floor(Math.random() * vchf_state.deck.length);
            const card = vchf_state.deck[randomIndex];
            
            takeSphere(card, 'enemy');
            vchf_state.isAISelecting = false;
            logStatus("ТВОЙ ВЫБОР В КРУГУ");

            if (vchf_state.deck.length === 0) finalizeGathering();
        }

        function takeSphere(card, owner) {
            const index = vchf_state.deck.findIndex(c => c.id === card.id);
            if (index === -1) return;

            vchf_state.deck.splice(index, 1);
            const sphereEl = document.getElementById(card.id);
            
            // Анимация полета в зависимости от владельца
            if (owner === 'player') {
                vchf_state.pHand.push(card);
                animateToBud(sphereEl);
            } else {
                vchf_state.eHand.push(card);
                animateToShadow(sphereEl);
            }
        }

        function animateToBud(el) {
            el.style.zIndex = "1000";
            el.style.transform = "scale(1.5) rotate(0deg)";
            el.style.opacity = "0";
            el.style.top = "80%"; // Полет в сторону Бутона
            
            setTimeout(() => {
                el.remove();
                renderBud();
                checkRitualEnd();
            }, 500);
        }

        function animateToShadow(el) {
            el.style.zIndex = "1000";
            el.style.top = "-100px"; // Улет за верх экрана (в руку ИИ)
            el.style.transform = "scale(0.1)";
            el.style.opacity = "0";
            setTimeout(() => {
                el.remove();
                checkRitualEnd();
            }, 500);
        }

        function checkRitualEnd() {
            if (vchf_state.deck.length === 0 && vchf_state.phase === 'gathering') {
                finalizeGathering();
            }
        }

        function finalizeGathering() {
            vchf_state.phase = 'anim';
            logStatus("РИТУАЛ РОЖДЕНИЯ КОЗЫРЯ...");
            
            // Появление Бутона (раскрытие)
            const bud = document.getElementById('vchf-bud');
            bud.style.display = 'flex';

            // Выбор козыря (Тотен)
            vchf_state.trump = SUITS[Math.floor(Math.random() * SUITS.length)];
            
            const totem = document.getElementById('totem');
            totem.innerText = vchf_state.trump;
            totem.style.color = (vchf_state.trump === '♥' || vchf_state.trump === '♦') ? 'var(--chaos-red)' : '#fff';
            
            // Стадия 1: Рождение (Захват ожидания)
            setTimeout(() => {
                totem.classList.add('born');
            }, 500);

            // Стадия 2: Полет в угол и активация Ауры
            setTimeout(() => {
                totem.classList.replace('born', 'fly');
                activateTrumpAura();
                vchf_state.phase = 'battle';
                logStatus("БИТВА НАЧАТА. ВАШ ХОД.");
                renderBud(); // Перерисовка с золотыми границами козырей
            }, 2000);
        }

        function activateTrumpAura() {
            const rowIds = {
                '♥': 'row-hearts',
                '♦': 'row-diamonds',
                '♣': 'row-clubs',
                '♠': 'row-spades'
            };
            const targetRow = document.getElementById(rowIds[vchf_state.trump]);
            if (targetRow) {
                targetRow.classList.add('trump-aura');
            }
        }
        // --- WINDOW 4: SPARK ENGINE (INTEGRATED BRAIN) ---

        function handleCardPlay(card) {
            if (vchf_state.phase !== 'battle' || vchf_state.turn !== 'player') return;

            // Логика атаки игрока
            if (vchf_state.table.length === 0 || vchf_state.table.length % 2 === 0) {
                if (canAttack(card)) {
                    moveCardToBattle(card, 'player', 'attack');
                    setTimeout(enemyBrain, 800);
                }
            } 
            // Логика защиты игрока
            else {
                if (canDefend(card)) {
                    moveCardToBattle(card, 'player', 'defend');
                    checkBitoAbility();
                    setTimeout(enemyBrain, 800);
                }
            }
        }

        function canAttack(card) {
            if (vchf_state.table.length === 0) return true;
            if (vchf_state.table.length >= 12) return false;
            // Можно подкидывать только те достоинства, что уже есть на столе
            return vchf_state.table.some(t => t.card.rank === card.rank);
        }

        function canDefend(card) {
            const lastAttack = [...vchf_state.table].reverse().find(t => t.type === 'attack');
            if (!lastAttack) return false;
            const a = lastAttack.card;

            // Обычный бой (масть в масть, выше номинал)
            if (card.suit === a.suit && card.val > a.val) return true;
            // Козырь бьет простую масть
            if (card.suit === vchf_state.trump && a.suit !== vchf_state.trump) return true;
            // Зеркальный удар (если активен раунд смены козыря)
            if (vchf_state.isMirrorRound && card.suit === vchf_state.oldTrump) return true;

            return false;
        }

        function enemyBrain() {
            if (!vchf_state.active) return;

            if (vchf_state.turn === 'player') {
                // ИИ В ОБОРОНЕ
                const lastAttack = [...vchf_state.table].reverse().find(t => t.type === 'attack');
                if (!lastAttack) return;

                // Поиск карты для защиты
                const defenseCard = vchf_state.eHand.filter(c => {
                    if (c.suit === lastAttack.card.suit && c.val > lastAttack.card.val) return true;
                    if (c.suit === vchf_state.trump && lastAttack.card.suit !== vchf_state.trump) return true;
                    return false;
                }).sort((a, b) => a.val - b.val)[0]; // Берет самую слабую из подходящих

                // Стратегия: не отдавать козырного Туза/Короля на мелкую карту
                if (defenseCard && defenseCard.val > 12 && lastAttack.card.val < 9 && Math.random() > 0.4) {
                    handleTake('enemy');
                    return;
                }

                if (defenseCard) {
                    moveCardToBattle(defenseCard, 'enemy', 'defend');
                } else {
                    handleTake('enemy');
                }
            } else {
                // ИИ В АТАКЕ
                let attackCard;
                if (vchf_state.table.length === 0) {
                    // Первый ход: мелкая карта или внезапный блеф
                    const sorted = vchf_state.eHand.sort((a,b) => a.val - b.val);
                    attackCard = Math.random() > 0.8 ? sorted[sorted.length-1] : sorted[0];
                } else {
                    // Подкидывание (Спарк-логика)
                    attackCard = vchf_state.eHand.find(c => canAttack(c));
                }

                if (attackCard && vchf_state.table.length < 12) {
                    moveCardToBattle(attackCard, 'enemy', 'attack');
                } else {
                    handleBito();
                }
            }
            renderBud();
        }

        function moveCardToBattle(card, owner, type) {
            const hand = owner === 'player' ? vchf_state.pHand : vchf_state.eHand;
            const idx = hand.findIndex(c => c.id === card.id);
            hand.splice(idx, 1);

            vchf_state.table.push({ card, type, owner });
            
            const battleGround = document.getElementById('battle-ground');
            const cardEl = document.createElement('div');
            cardEl.className = `card-face ${card.suit === vchf_state.trump ? 'trump-border' : ''}`;
            if (card.suit === '♥' || card.suit === '♦') cardEl.classList.add('red');
            
            // Легкий хаос в расположении карт на столе
            const randomRot = Math.random() * 20 - 10;
            cardEl.style.transform = `rotate(${randomRot}deg)`;
            
            cardEl.innerHTML = `
                <div>${card.rank}</div>
                <div style="font-size:24px; align-self:center;">${card.suit}</div>
                <div style="transform:rotate(180deg);">${card.rank}</div>
            `;
            battleGround.appendChild(cardEl);

            // Переключение фазы
            if (type === 'attack') {
                logStatus(owner === 'player' ? "ИИ ЗАЩИЩАЕТСЯ..." : "ВАША ОЧЕРЕДЬ ЗАЩИЩАТЬСЯ");
            }
            checkBitoAbility();
        }

        function checkBitoAbility() {
            const btn = document.getElementById('btn-bito');
            // Кнопка активна, если на столе есть карты и они все побиты (парное количество)
            const isAllDefended = vchf_state.table.length > 0 && vchf_state.table.length % 2 === 0;
            btn.disabled = !(vchf_state.turn === 'player' && isAllDefended);
        }
        // --- WINDOW 5: CHAOS TIMER & TAKE LOGIC ---

        let vchf_timer_interval = null;

        function startChaosTimer() {
            if (vchf_timer_interval) clearInterval(vchf_timer_interval);
            let timeLeft = 100;
            
            // Визуальный индикатор Хаоса (если добавим полоску позже)
            vchf_timer_interval = setInterval(() => {
                if (vchf_state.phase === 'take_window' || !vchf_state.active) return;

                timeLeft -= 0.5; // Скорость сгорания стабильности

                if (timeLeft <= 0) {
                    initMirrorShift();
                    timeLeft = 100;
                }
            }, 200);
        }

        function initMirrorShift() {
            vchf_state.oldTrump = vchf_state.trump;
            let nextTrump;
            do {
                nextTrump = SUITS[Math.floor(Math.random() * SUITS.length)];
            } while (nextTrump === vchf_state.trump);

            vchf_state.trump = nextTrump;
            vchf_state.isMirrorRound = true;
            
            // Визуализация смены Тотена
            const totem = document.getElementById('totem');
            totem.innerText = vchf_state.trump;
            totem.style.color = (vchf_state.trump === '♥' || vchf_state.trump === '♦') ? 'var(--chaos-red)' : '#fff';
            totem.style.filter = "drop-shadow(0 0 40px var(--gold))";
            
            logStatus("ЗЕРКАЛЬНЫЙ РАУНД: СМЕНА КОЗЫРЯ!");
            
            // Смена золотой ауры в Бутоне
            document.querySelectorAll('.suit-row').forEach(r => r.classList.remove('trump-aura'));
            activateTrumpAura();
            renderBud(); 

            // Зеркальный эффект (старый козырь бьет еще 7 секунд)
            setTimeout(() => {
                vchf_state.isMirrorRound = false;
                totem.style.filter = "none";
                logStatus("ХАОС СТАБИЛИЗИРОВАН");
                renderBud();
            }, 7000);
        }

        function handleTake(who = 'player') {
            if (vchf_state.table.length === 0) return;
            vchf_state.phase = 'take_window';
            
            logStatus(`ОКНО СБРОСА (5 СЕК) - ${who === 'player' ? 'ВЫ БЕРЕТЕ' : 'ИИ БЕРЕТ'}`);

            let sec = 5;
            const takeCountdown = setInterval(() => {
                sec--;
                if (sec <= 0) {
                    clearInterval(takeCountdown);
                    finalizeTake(who);
                } else {
                    logStatus(`СБРОС ВДОГОНКУ: ${sec} сек...`);
                    // ИИ пытается подкинуть, если берет игрок
                    if (who === 'player') enemyTossIn();
                }
            }, 1000);
        }

        function enemyTossIn() {
            if (vchf_state.phase !== 'take_window') return;
            const tossCard = vchf_state.eHand.find(c => canAttack(c));
            if (tossCard && vchf_state.table.length < 12) {
                moveCardToBattle(tossCard, 'enemy', 'attack');
            }
        }

        function finalizeTake(who) {
            const tableCards = vchf_state.table.map(t => t.card);
            const tableEl = document.getElementById('battle-ground');
            
            if (who === 'player') {
                vchf_state.pHand.push(...tableCards);
                vchf_state.turn = 'enemy';
            } else {
                vchf_state.eHand.push(...tableCards);
                vchf_state.turn = 'player';
            }

            vchf_state.table = [];
            vchf_state.phase = 'battle';
            tableEl.innerHTML = '';
            
            renderBud();
            checkEndGame();

            if (vchf_state.turn === 'enemy') {
                setTimeout(enemyBrain, 1500);
            } else {
                logStatus("ВАШ ХОД (АТАКА)");
            }
        }

        function handleBito() {
            if (vchf_state.table.length === 0 || vchf_state.table.length % 2 !== 0) return;
            
            vchf_state.table = [];
            vchf_state.turn = vchf_state.turn === 'player' ? 'enemy' : 'player';
            vchf_state.phase = 'battle';
            document.getElementById('battle-ground').innerHTML = '';
            
            logStatus(vchf_state.turn === 'player' ? "БИТО. ВАШ ХОД" : "БИТО. ХОД ИИ");
            renderBud();
            checkEndGame();
            
            if (vchf_state.turn === 'enemy') {
                setTimeout(enemyBrain, 1500);
            }
        }
        // --- WINDOW 6: FINAL RITUAL & ENDGAME CONDITION ---

        function checkEndGame() {
            if (vchf_state.phase === 'gathering') return;

            const pCount = vchf_state.pHand.length;
            const eCount = vchf_state.eHand.length;

            // Если колода пуста и у кого-то кончились карты
            if (vchf_state.deck.length === 0) {
                if (pCount === 0 && eCount === 0) {
                    showEndScreen("НИЧЬЯ — ХАОС СБАЛАНСИРОВАН");
                } else if (pCount === 0) {
                    showEndScreen("WANDERER, ТЫ ПОБЕДИЛ СИСТЕМУ!");
                } else if (eCount === 0) {
                    showEndScreen("НУЛЕВОЙ ХАОС ДОМИНИРУЕТ. REBOOT?");
                }
            }
        }

        function showEndScreen(msg) {
            vchf_state.active = false;
            if (vchf_timer_interval) clearInterval(vchf_timer_interval);

            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.95); z-index: 10000;
                display: flex; flex-direction: column; justify-content: center;
                align-items: center; font-family: 'Orbitron', sans-serif;
                color: var(--gold); text-align: center; padding: 20px;
            `;
            
            overlay.innerHTML = `
                <h2 style="font-size: 24px; margin-bottom: 20px; letter-spacing: 5px;">${msg}</h2>
                <div style="margin-bottom: 30px; color: #fff; font-size: 12px; opacity: 0.7;">
                    МАНИФЕСТ МОНОЛИТА: <br> ИГРА ЧЕРЕЗ ДВИЖОК — ЭТО ШАНС. <br> БОЛЬШЕ БИЛЕТОВ — БОЛЬШЕ ХАОСА.
                </div>
                <button class="ready-trigger" onclick="location.reload()">НОВЫЙ ЦИКЛ</button>
            `;
            document.body.appendChild(overlay);
        }

        // РИТУАЛЬНЫЙ ХОЛСТ (BACKDROP ИЗ МУСТЕРА)
        const canvas = document.getElementById('ritual-canvas');
        const ctx = canvas.getContext('2d');
        let particles = [];

        function initCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            particles = [];
            for(let i=0; i<60; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    v: Math.random() * 0.4 + 0.1,
                    s: Math.random() * 1.5,
                    o: Math.random() * 0.5 + 0.2
                });
            }
        }

        function drawRitualBG() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#00ff00';
            particles.forEach(p => {
                p.y -= p.v;
                if(p.y < 0) p.y = canvas.height;
                ctx.globalAlpha = p.o;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.s, 0, Math.PI*2);
                ctx.fill();
            });
            requestAnimationFrame(drawRitualBG);
        }

        // ЗАПУСК СИСТЕМЫ
        window.addEventListener('resize', initCanvas);
        initCanvas();
        drawRitualBG();

        // Запуск таймера при старте игры (вызывается из Window 2)
        const originalStartRitual = startRitual;
        startRitual = function() {
            originalStartRitual();
            startChaosTimer();
        };

        console.log("НУЛЕВОЙ ХАОС: МОНОЛИТ СОБРАН. 6/6.");
        console.log("WANDERER, ТВОЙ ТЕЛЕФОН ТЕПЕРЬ — ПОРТАЛ VCHF.");
    </script>
</body>
</html>
