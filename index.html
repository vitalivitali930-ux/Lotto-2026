<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>VCHF Durak | The Voice of Wanderer</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --cherry-velvet: radial-gradient(circle at center, #800020 0%, #2a0005 65%, #000 100%);
            --card-back: radial-gradient(circle, #000 25%, #5a0010 100%);
            --gold: #d4af37;
        }

        * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: var(--cherry-velvet); overflow: hidden; font-family: 'Orbitron', sans-serif; color: white; }

        /* Освещение */
        body::after {
            content: ''; position: fixed; top: 35%; left: 50%; transform: translate(-50%, -50%);
            width: 100vh; height: 100vh; background: radial-gradient(circle, rgba(255, 220, 100, 0.07) 0%, transparent 70%);
            pointer-events: none; z-index: 5;
        }

        #ui-wrapper { position: relative; width: 100%; height: 100vh; display: flex; flex-direction: column; justify-content: space-between; padding: 20px 10px; z-index: 10; }

        /* Облако фраз */
        .phrase-bubble {
            position: absolute; background: rgba(0,0,0,0.8); border: 1px solid var(--gold);
            padding: 8px 12px; border-radius: 10px; font-size: 10px; color: var(--gold);
            max-width: 150px; text-align: center; pointer-events: none;
            opacity: 0; transform: translateY(0); transition: 0.4s; z-index: 100;
        }
        .show-phrase { opacity: 1; transform: translateY(-20px); }

        /* Колода слева */
        #deck-side { position: absolute; left: 10px; top: 50%; transform: translateY(-50%); width: 70px; height: 100px; }
        .trump-base { position: absolute; width: 65px; height: 95px; background: #fff; border-radius: 5px; transform: rotate(90deg) translate(20px, 15px); border: 1px solid var(--gold); color: #000; font-weight: 900; padding: 5px; display: flex; flex-direction: column; justify-content: space-between; font-size: 11px; }
        .deck-top { position: absolute; width: 65px; height: 95px; background: var(--card-back); border-radius: 5px; border: 1.5px solid var(--gold); z-index: 2; display: flex; align-items: center; justify-content: center; box-shadow: -4px 4px 15px #000; }
        .deck-top img { width: 85%; }

        .hand { display: flex; justify-content: center; width: 100%; height: 110px; position: relative; }
        #enemy-hand { transform: rotate(180deg); }

        #table-zone { flex-grow: 1; display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; align-content: center; max-width: 450px; margin: auto; }

        .card { width: 70px; height: 100px; background: #fff; border-radius: 6px; color: #000; display: flex; flex-direction: column; justify-content: space-between; padding: 4px; font-weight: 900; box-shadow: 0 5px 15px rgba(0,0,0,0.5); transition: 0.3s; position: relative; }
        .card.red { color: #d00; }
        .card.back { background: var(--card-back); border: 1.2px solid var(--gold); }
        .card.back img { width: 80%; margin: auto; display: block; }
        #player-hand .card:hover { transform: translateY(-20px); z-index: 50; border-color: var(--gold); }

        /* Кнопки справа */
        #controls { position: absolute; right: 15px; bottom: 130px; display: flex; flex-direction: column; gap: 10px; }
        .btn-vchf { background: #000; border: 1.5px solid var(--gold); color: var(--gold); padding: 12px 15px; border-radius: 4px; font-family: 'Orbitron'; font-size: 10px; font-weight: 900; cursor: pointer; text-transform: uppercase; }
        .btn-vchf:disabled { opacity: 0.2; }

        #status-bar { position: absolute; top: 10px; width: 100%; text-align: center; color: var(--gold); font-size: 9px; letter-spacing: 3px; opacity: 0.6; }
    </style>
</head>
<body>

<div id="ui-wrapper">
    <div id="status-bar">VCHF ENGINE 2.3 ACTIVE</div>
    
    <div id="phrase-player" class="phrase-bubble" style="bottom: 140px; left: 50%; transform: translateX(-50%);"></div>
    <div id="phrase-enemy" class="phrase-bubble" style="top: 140px; left: 50%; transform: translateX(-50%);"></div>

    <div id="deck-side">
        <div id="trump-slot" class="trump-base"></div>
        <div id="deck-stack" class="deck-top"><img src="1771489965074(1).png"></div>
    </div>

    <div id="enemy-hand" class="hand"></div>
    <div id="table-zone"></div>

    <div id="controls">
        <button id="main-btn" class="btn-vchf" onclick="core.handleAction()">ХОД</button>
        <button class="btn-vchf" style="opacity:0.4" onclick="location.reload()">EXIT</button>
    </div>

    <div id="player-hand" class="hand"></div>
</div>

<script>
/** * МАНИФЕСТ МОНОЛИТА. Искра для Бродяги.
 * [2026-02-26] Интеграция разговорного движка.
 */
const tg = window.Telegram.WebApp;
const suits = ['♠', '♣', '♥', '♦'], vals = ['6','7','8','9','10','J','Q','K','A'];
const pwr = {'6':6,'7':7,'8':8,'9':9,'10':10,'J':11,'Q':12,'K':13,'A':14};

const PHRASES = {
    attack: ["Ходи не с бубей, а с людей!", "Под лопаточку!", "Не по Сеньке шапка!", "Карта не лошадь - к утру вывезет!", "На тебе боже, что нам негоже!"],
    defend: ["Чем богаты, тем и рады!", "Бью козырем, сплю с гонором!", "Мало козырей, да все мои!", "Не замай!", "Туз на погон!"],
    take: ["Бери-бери, в хозяйстве пригодится...", "Ой, гребу лопатой!", "Это мне на десерт?", "Своя ноша не тянет!", "Затарился по полной."],
    bito: ["Чисто сработано!", "В отбой её!", "Бито, не крыто!", "Следующий заход!", "Хорошо пошла!"]
};

const core = {
    deck: [], pHand: [], eHand: [], table: [], trump: null, isPAttack: true,

    init() {
        this.deck = [];
        suits.forEach(s => vals.forEach(v => this.deck.push({s, v, red: (s==='♥'||s==='♦')})));
        this.deck.sort(() => Math.random() - 0.5);
        this.trump = this.deck[0];
        this.refill();
        this.render();
        this.speak('enemy', "Ну что, Бродяга, раскинем?");
    },

    refill() {
        while(this.pHand.length < 6 && this.deck.length > 0) this.pHand.push(this.deck.pop());
        while(this.eHand.length < 6 && this.deck.length > 0) this.eHand.push(this.deck.pop());
    },

    speak(who, text) {
        const el = document.getElementById('phrase-' + who);
        el.innerText = text;
        el.classList.add('show-phrase');
        setTimeout(() => el.classList.remove('show-phrase'), 2500);
    },

    render() {
        const ts = document.getElementById('trump-slot');
        ts.innerHTML = `<div>${this.trump.s}</div><div style="font-size:18px">${this.trump.v}</div>`;
        if(this.trump.red) ts.style.color = '#d00';
        document.getElementById('deck-stack').style.display = this.deck.length > 1 ? 'flex' : 'none';

        const ph = document.getElementById('player-hand'); ph.innerHTML = '';
        this.pHand.sort((a,b) => pwr[a.v] - pwr[b.v]).forEach((c, i) => {
            const el = this.createUI(c);
            el.onclick = () => this.play(i);
            ph.appendChild(el);
        });

        const eh = document.getElementById('enemy-hand'); eh.innerHTML = '';
        this.eHand.forEach(() => eh.appendChild(this.createUI(null, true)));

        const tz = document.getElementById('table-zone'); tz.innerHTML = '';
        this.table.forEach(pair => {
            const w = document.createElement('div'); w.style.position = 'relative';
            w.appendChild(this.createUI(pair.at));
            if(pair.df) {
                const df = this.createUI(pair.df);
                df.style.position = 'absolute'; df.style.top = '15px'; df.style.left = '10px'; df.style.zIndex = '10';
                w.appendChild(df);
            }
            tz.appendChild(w);
        });
        this.updBtn();
    },

    createUI(c, back = false) {
        const d = document.createElement('div');
        d.className = 'card' + (back ? ' back' : (c.red ? ' red' : ''));
        if(back) d.innerHTML = `<img src="1771489965074(1).png">`;
        else d.innerHTML = `<div>${c.s}</div><div style="font-size:20px;align-self:center">${c.v}</div><div style="align-self:flex-end">${c.s}</div>`;
        return d;
    },

    play(idx) {
        const c = this.pHand[idx];
        if(this.isPAttack) {
            if(this.table.length >= 6) return;
            if(this.table.length > 0) {
                const onT = this.table.flatMap(p => [p.at.v, p.df?.v]).filter(Boolean);
                if(!onT.includes(c.v)) return;
            }
            this.table.push({at: c, df: null});
            this.pHand.splice(idx, 1);
            this.speak('player', PHRASES.attack[Math.floor(Math.random()*PHRASES.attack.length)]);
            setTimeout(() => this.aiDefend(), 600);
        } else {
            const target = this.table.find(p => !p.df);
            if(target && (c.s === target.at.s ? pwr[c.v] > pwr[target.at.v] : c.s === this.trump.s)) {
                target.df = c; this.pHand.splice(idx, 1);
                this.speak('player', PHRASES.defend[Math.floor(Math.random()*PHRASES.defend.length)]);
                setTimeout(() => this.aiAttack(), 800);
            }
        }
        this.render();
    },

    aiDefend() {
        const p = this.table.find(p => !p.df);
        if(!p) return;
        let best = this.eHand.filter(c => (c.s===p.at.s?pwr[c.v]>pwr[p.at.v]:c.s===this.trump.s))
                    .sort((a,b) => (a.s===this.trump.s)-(b.s===this.trump.s) || pwr[a.v]-pwr[b.v])[0];
        if(best) {
            p.df = this.eHand.splice(this.eHand.indexOf(best), 1)[0];
            this.speak('enemy', PHRASES.defend[Math.floor(Math.random()*PHRASES.defend.length)]);
        } else {
            this.speak('enemy', PHRASES.take[Math.floor(Math.random()*PHRASES.take.length)]);
        }
        this.render();
    },

    aiAttack() {
        if(!this.isPAttack) {
            const onT = this.table.flatMap(p => [p.at.v, p.df?.v]).filter(Boolean);
            let best = this.eHand.filter(c => onT.length===0 || onT.includes(c.v))
                        .sort((a,b) => (a.s===this.trump.s)-(b.s===this.trump.s) || pwr[a.v]-pwr[b.v])[0];
            if(best && this.table.length < 6) {
                this.table.push({at: this.eHand.splice(this.eHand.indexOf(best), 1)[0], df: null});
                this.speak('enemy', PHRASES.attack[Math.floor(Math.random()*PHRASES.attack.length)]);
            } else {
                this.speak('enemy', "Бито, пожалуй.");
            }
        }
        this.render();
    },

    handleAction() {
        const btn = document.getElementById('main-btn');
        if(btn.innerText === "БИТО") {
            this.speak(this.isPAttack ? 'player' : 'enemy', PHRASES.bito[Math.floor(Math.random()*PHRASES.bito.length)]);
            this.table = []; this.refill();
            this.isPAttack = !this.isPAttack;
            if(!this.isPAttack) setTimeout(() => this.aiAttack(), 600);
        } else if(btn.innerText === "ВЗЯТЬ") {
            const all = this.table.flatMap(p => [p.at, p.df]).filter(Boolean);
            if(this.isPAttack) { this.eHand.push(...all); this.speak('enemy', "Забираю..."); }
            else { this.pHand.push(...all); this.speak('player', "Придётся брать."); }
            this.table = []; this.refill();
            if(!this.isPAttack) setTimeout(() => this.aiAttack(), 600);
        }
        this.render();
    },

    updBtn() {
        const b = document.getElementById('main-btn');
        const hasUn = this.table.some(p => !p.df);
        if(this.isPAttack) {
            b.innerText = (this.table.length > 0 && !hasUn) ? "БИТО" : "ХОД";
            b.disabled = hasUn && this.table.length > 0;
        } else {
            b.innerText = hasUn ? "ВЗЯТЬ" : "БИТО";
        }
    }
};

core.init();
</script>
</body>
</html>
