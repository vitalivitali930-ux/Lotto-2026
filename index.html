import random
import asyncio
import sqlite3
import logging
from aiogram import Bot, Dispatcher, types, F, exceptions
from aiogram.filters import Command
from aiogram.utils.keyboard import InlineKeyboardBuilder
from apscheduler.schedulers.asyncio import AsyncIOScheduler

# --- ĞĞĞ¡Ğ¢Ğ ĞĞ™ĞšĞ˜ ---
TOKEN = "7659579628:AAG1EdW81IVcGoAGEe7ymK6aYMxjm4Pyk3E"
CHANNEL_ID = "@your_channel_name" 
TICKET_PRICE = 2.50

logging.basicConfig(level=logging.INFO)
bot = Bot(token=TOKEN)
dp = Dispatcher()
scheduler = AsyncIOScheduler()

# --- Ğ›ĞĞ“Ğ˜ĞšĞ Ğ‘ĞĞ—Ğ« Ğ”ĞĞĞĞ«Ğ¥ Ğ˜ Ğ¢Ğ ĞĞĞ—ĞĞšĞ¦Ğ˜Ğ™ ---
def db_transaction_purchase(user_id: int, quantity: int):
    """Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµÑ‚ Ğ¿Ğ¾ĞºÑƒĞ¿ĞºÑƒ Ğ²Ğ½ÑƒÑ‚Ñ€Ğ¸ Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ğ¸ Ğ‘Ğ” Ğ´Ğ»Ñ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸"""
    total_cost = quantity * TICKET_PRICE
    conn = sqlite3.connect('lotto_ultimate.db', timeout=10)
    cursor = conn.cursor()
    
    try:
        cursor.execute("BEGIN EXCLUSIVE TRANSACTION")
        
        # 1. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ
        cursor.execute("SELECT balance FROM users WHERE user_id = ?", (user_id,))
        res = cursor.fetchone()
        
        if not res or res[0] < total_cost:
            return False, "ĞĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ ÑÑ€ĞµĞ´ÑÑ‚Ğ²"
        
        # 2. Ğ¡Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµĞ¼ ÑÑ€ĞµĞ´ÑÑ‚Ğ²Ğ°
        cursor.execute("UPDATE users SET balance = balance - ? WHERE user_id = ?", (total_cost, user_id))
        
        # 3. ĞĞ°Ğ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼ ĞºĞ°Ğ·Ğ½Ñƒ
        cursor.execute("UPDATE treasury SET balance = balance + ?", (total_cost,))
        
        # 4. ĞŸĞ°ĞºĞµÑ‚Ğ½Ğ°Ñ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ±Ğ¸Ğ»ĞµÑ‚Ğ¾Ğ²
        tickets_data = []
        for _ in range(quantity):
            nums = ",".join(map(str, sorted(random.sample(range(1, 43), 6))))
            tickets_data.append((user_id, nums))
            
        cursor.executemany("INSERT INTO tickets (user_id, numbers) VALUES (?, ?)", tickets_data)
        
        conn.commit()
        return True, "Ğ£ÑĞ¿ĞµÑˆĞ½Ğ¾"
    except Exception as e:
        conn.rollback()
        logging.error(f"DB Error: {e}")
        return False, "ĞÑˆĞ¸Ğ±ĞºĞ° Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…"
    finally:
        conn.close()

# --- Ğ¨ĞĞ‘Ğ›ĞĞĞ« Ğ¢Ğ•ĞšĞ¡Ğ¢ĞĞ’ ---
def get_main_menu_text():
    return (
        "ğŸ° <b>ğ•¾ğ–œğ–ğ–˜ğ–˜ ğ•·ğ–šğ–ˆğ– | ğ•»ğ–—ğ–Šğ–’ğ–ğ–šğ–’ ğ•¶ğ–†ğ–‡ğ–ğ–“ğ–Šğ–™ğ–™</b>\n\n"
        "ğŸŸ¡ <b>ğ•ğ•€â„‚â„ğ•‹ğ•€ğ”¾ğ•Šğ•‹ğ”¼ (PrioritÃ¤t 1)</b>\n"
        "ğŸ† Status: <code>ğ”Šğ”’ğ”ğ”‡ ğ”â„‘ğ”—ğ”Šğ”â„‘ğ”ˆğ”‡</code> ğŸ‘‘\n"
        "ğŸ’° Guthaben: <code>1,250.00 CHF</code>\n\n"
        "ğŸ”µ <b>â„‘ğ”‘ğ”‰ğ”’â„œğ”ğ”„ğ”—â„‘ğ”’ğ”‘ (PrioritÃ¤t 2)</b>\n"
        "ğŸ‘¤ Teilnehmer: <code>ID-777-LUCK</code>\n"
        "ğŸ‘¥ Ihr Team: <b>ZÃ¼rich Lions</b> ğŸ¦\n"
        "______________________________________"
    )

# --- ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜ĞšĞ˜ ---
@dp.message(Command("start"))
async def cmd_start(message: types.Message):
    builder = InlineKeyboardBuilder()
    builder.row(types.InlineKeyboardButton(text="ğŸŸ¡ ğ”—ğ”¦ğ” ğ”¨ğ”¢ğ”±ğ”° ğ”¨ğ”ğ”²ğ”£ğ”¢ğ”«", callback_data="buy_menu"))
    await message.answer(get_main_menu_text(), reply_markup=builder.as_markup(), parse_mode="HTML")

@dp.callback_query(F.data == "buy_menu")
async def cmd_buy(callback: types.CallbackQuery):
    builder = InlineKeyboardBuilder()
    builder.row(types.InlineKeyboardButton(text="ğŸŸ 1 Ticket", callback_data="buy:1"))
    builder.row(types.InlineKeyboardButton(text="ğŸŸ 5 Tickets", callback_data="buy:5"))
    builder.row(types.InlineKeyboardButton(text="â¬… ZurÃ¼ck", callback_data="back_to_main"))
    
    await callback.message.edit_text("ğŸ° <b>ğ•¿ğ–ğ–ˆğ–‡ğ–Šğ–™ ğ•¾ğ–ğ–”ğ–•</b>\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾:", 
                                    reply_markup=builder.as_markup(), parse_mode="HTML")

@dp.callback_query(F.data.startswith("buy:"))
async def process_purchase(callback: types.CallbackQuery):
    qty = int(callback.data.split(":")[1])
    if qty <= 0: return

    success, message = db_transaction_purchase(callback.from_user.id, qty)
    
    if success:
        await callback.message.edit_text(f"âœ… <b>Ğ£ÑĞ¿ĞµÑˆĞ½Ğ¾!</b>\nĞšÑƒĞ¿Ğ»ĞµĞ½Ğ¾ Ğ±Ğ¸Ğ»ĞµÑ‚Ğ¾Ğ²: {qty}\nğŸ€ Ğ£Ğ´Ğ°Ñ‡Ğ¸!", parse_mode="HTML")
    else:
        await callback.answer(f"âŒ {message}", show_alert=True)
    await callback.answer()

# --- ĞĞ’Ğ¢Ğ-ĞĞ¢Ğ§Ğ•Ğ¢ Ğ’ ĞšĞĞĞĞ› ---
async def publish_results():
    try:
        conn = sqlite3.connect('lotto_ultimate.db')
        cursor = conn.cursor()
        cursor.execute("SELECT balance FROM treasury LIMIT 1")
        balance = cursor.fetchone()[0]
        conn.close()

        text = (f"ğŸ° <b>ğ•¾ğ–œğ–ğ–˜ğ–˜ ğ•·ğ–šğ–ˆğ– | ğ•­ğ–Šğ–—ğ–ğ–ˆğ–ğ–™</b>\n"
                f"ğŸ’° Ğ’ ĞºĞ°Ğ·Ğ½Ğµ Ğ½Ğ°ĞºĞ¾Ğ¿Ğ»ĞµĞ½Ğ¾: <code>{balance:.2f} CHF</code>")
        await bot.send_message(CHANNEL_ID, text, parse_mode="HTML")
    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ñ‡ĞµÑ‚Ğ°: {e}")

# --- Ğ—ĞĞŸĞ£Ğ¡Ğš ---
async def main():
    scheduler.add_job(publish_results, "cron", day_of_week="wed,sat", hour=19, minute=0)
    scheduler.start()
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
